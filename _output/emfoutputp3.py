
import os
import psycopg2
import psycopg2.extras
import tabulate
from dotenv import load_dotenv
# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py

def update_agg_value(agg_table, grouping_variable, row):
    # First, iterate through the aggregate functions.
    for func in agg_table:
        starting_val = agg_table[func]
        # Input is labeled as (ex: 1_avg_quant), so must account for that.
        func_args = func.split('_')
        func_grouping_val = int(func_args[0])
        tracked_val = func_args[2]
        new_value = row[tracked_val]
        
        # Do NOT update if the function grouping variable is not equivalent to the grouping variable.
        if (func_grouping_val != grouping_variable):
            continue
        # Note: avg is a pair, so you need to update the sum and the count before you divide at the end.
        if func_args[1] == 'avg':
            starting_val[0] += new_value
            starting_val[1] += 1
        elif func_args[1] == 'min':
            starting_val = min(new_value, starting_val)
        elif func_args[1] == 'max':
            starting_val = max(new_value, starting_val)
        elif func_args[1] == 'sum':
            starting_val += new_value
        elif func_args[1] == 'count':
            starting_val += 1
        else: 
            ## Should not occur!
            raise Exception("Invalid aggregate function.")
        # Finally, update the value. Done!
        agg_table[func] = starting_val

def query():
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname="+dbname+" user="+user+" password="+password,
                            cursor_factory=psycopg2.extras.DictCursor)
    cur = conn.cursor()
    cur.execute("SELECT * FROM sales")
    data = cur.fetchall()
    
    _global = []
    
    # Step 1: Gather unique "groupby"s (mf_struct)
    groupby = {}
    for row in data:
        key = str(row['cust']) + "," +str(row['prod'])
        if key not in groupby:
            groupby[key] = {
                 '1_sum_quant' : 0,
                 '2_sum_quant' : 0,
                
            }
        else:
            pass
    # Step 2: Instead of one pass, this is now based on the number of grouping variables.
    # Iterate through and check predicates.
    
    for row in data:
        grouping_attr = str(row['cust']) + "," +str(row['prod'])
        if row['year'] == 2017:
            for key in groupby:
                grouping_var = 0 
                grouping_attrs = key.split(',')
                for item in grouping_attrs:
                    if item.isnumeric():
                        grouping_attrs[grouping_attrs.index(item)] = int(item)
                # Generated code as seen in helper.py methods.
                item_cust = grouping_attrs[0]
                item_prod = grouping_attrs[1]
                
                if row['cust'] ==  item_cust  and row['prod'] ==  item_prod :
                    grouping_var = 1
                else:
                    continue
                change_group = groupby[key]
                update_agg_value(change_group, grouping_var, row)
            
    for row in data:
        grouping_attr = str(row['cust']) + "," +str(row['prod'])
        if row['year'] == 2017:
            for key in groupby:
                grouping_var = 0 
                grouping_attrs = key.split(',')
                for item in grouping_attrs:
                    if item.isnumeric():
                        grouping_attrs[grouping_attrs.index(item)] = int(item)
                # Generated code as seen in helper.py methods.
                item_cust = grouping_attrs[0]
                item_prod = grouping_attrs[1]
                
                if row['cust'] ==  item_cust  and row['prod'] !=  item_prod :
                    grouping_var = 2
                else:
                    continue
                change_group = groupby[key]
                update_agg_value(change_group, grouping_var, row)
            
    # Step 3: Revise averages, just like in an MF Query
    for grouping_attr_key, grouping_attr in groupby.items():
        for agg_func_key, agg_func in grouping_attr.items():
            if 'avg' in agg_func_key:
                avg_list = groupby[grouping_attr_key][agg_func_key]
                if avg_list[1] == 0:
                    groupby[grouping_attr_key][agg_func_key] = 0
                else:
                    groupby[grouping_attr_key][agg_func_key] = avg_list[0]/avg_list[1] 
    # Step 4: Filter out table using the having clause.
        if True:
            _global.append({ 'cust,prod': grouping_attr_key,'1_sum_quant':groupby[grouping_attr_key]['1_sum_quant'],'2_sum_quant':groupby[grouping_attr_key]['2_sum_quant'],})
        
    
    return tabulate.tabulate(_global,
                        headers="keys", tablefmt="psql")

def main():
    print(query())
    
if "__main__" == __name__:
    main()
    